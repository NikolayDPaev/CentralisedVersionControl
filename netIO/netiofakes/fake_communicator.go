// Code generated by counterfeiter. DO NOT EDIT.
package netiofakes

import (
	"io"
	"sync"

	"github.com/NikolayDPaev/CentralisedVersionControl/netio"
)

type FakeCommunicator struct {
	RecvFileDataStub        func(io.Writer) error
	recvFileDataMutex       sync.RWMutex
	recvFileDataArgsForCall []struct {
		arg1 io.Writer
	}
	recvFileDataReturns struct {
		result1 error
	}
	recvFileDataReturnsOnCall map[int]struct {
		result1 error
	}
	RecvStringStub        func() (string, error)
	recvStringMutex       sync.RWMutex
	recvStringArgsForCall []struct {
	}
	recvStringReturns struct {
		result1 string
		result2 error
	}
	recvStringReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	RecvStringSliceStub        func() ([]string, error)
	recvStringSliceMutex       sync.RWMutex
	recvStringSliceArgsForCall []struct {
	}
	recvStringSliceReturns struct {
		result1 []string
		result2 error
	}
	recvStringSliceReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	RecvVarIntStub        func() (int64, error)
	recvVarIntMutex       sync.RWMutex
	recvVarIntArgsForCall []struct {
	}
	recvVarIntReturns struct {
		result1 int64
		result2 error
	}
	recvVarIntReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	SendFileDataStub        func(io.Reader, int64) error
	sendFileDataMutex       sync.RWMutex
	sendFileDataArgsForCall []struct {
		arg1 io.Reader
		arg2 int64
	}
	sendFileDataReturns struct {
		result1 error
	}
	sendFileDataReturnsOnCall map[int]struct {
		result1 error
	}
	SendStringStub        func(string) error
	sendStringMutex       sync.RWMutex
	sendStringArgsForCall []struct {
		arg1 string
	}
	sendStringReturns struct {
		result1 error
	}
	sendStringReturnsOnCall map[int]struct {
		result1 error
	}
	SendStringSliceStub        func([]string) error
	sendStringSliceMutex       sync.RWMutex
	sendStringSliceArgsForCall []struct {
		arg1 []string
	}
	sendStringSliceReturns struct {
		result1 error
	}
	sendStringSliceReturnsOnCall map[int]struct {
		result1 error
	}
	SendVarIntStub        func(int64) error
	sendVarIntMutex       sync.RWMutex
	sendVarIntArgsForCall []struct {
		arg1 int64
	}
	sendVarIntReturns struct {
		result1 error
	}
	sendVarIntReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCommunicator) RecvFileData(arg1 io.Writer) error {
	fake.recvFileDataMutex.Lock()
	ret, specificReturn := fake.recvFileDataReturnsOnCall[len(fake.recvFileDataArgsForCall)]
	fake.recvFileDataArgsForCall = append(fake.recvFileDataArgsForCall, struct {
		arg1 io.Writer
	}{arg1})
	stub := fake.RecvFileDataStub
	fakeReturns := fake.recvFileDataReturns
	fake.recordInvocation("RecvFileData", []interface{}{arg1})
	fake.recvFileDataMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCommunicator) RecvFileDataCallCount() int {
	fake.recvFileDataMutex.RLock()
	defer fake.recvFileDataMutex.RUnlock()
	return len(fake.recvFileDataArgsForCall)
}

func (fake *FakeCommunicator) RecvFileDataCalls(stub func(io.Writer) error) {
	fake.recvFileDataMutex.Lock()
	defer fake.recvFileDataMutex.Unlock()
	fake.RecvFileDataStub = stub
}

func (fake *FakeCommunicator) RecvFileDataArgsForCall(i int) io.Writer {
	fake.recvFileDataMutex.RLock()
	defer fake.recvFileDataMutex.RUnlock()
	argsForCall := fake.recvFileDataArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCommunicator) RecvFileDataReturns(result1 error) {
	fake.recvFileDataMutex.Lock()
	defer fake.recvFileDataMutex.Unlock()
	fake.RecvFileDataStub = nil
	fake.recvFileDataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCommunicator) RecvFileDataReturnsOnCall(i int, result1 error) {
	fake.recvFileDataMutex.Lock()
	defer fake.recvFileDataMutex.Unlock()
	fake.RecvFileDataStub = nil
	if fake.recvFileDataReturnsOnCall == nil {
		fake.recvFileDataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.recvFileDataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCommunicator) RecvString() (string, error) {
	fake.recvStringMutex.Lock()
	ret, specificReturn := fake.recvStringReturnsOnCall[len(fake.recvStringArgsForCall)]
	fake.recvStringArgsForCall = append(fake.recvStringArgsForCall, struct {
	}{})
	stub := fake.RecvStringStub
	fakeReturns := fake.recvStringReturns
	fake.recordInvocation("RecvString", []interface{}{})
	fake.recvStringMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCommunicator) RecvStringCallCount() int {
	fake.recvStringMutex.RLock()
	defer fake.recvStringMutex.RUnlock()
	return len(fake.recvStringArgsForCall)
}

func (fake *FakeCommunicator) RecvStringCalls(stub func() (string, error)) {
	fake.recvStringMutex.Lock()
	defer fake.recvStringMutex.Unlock()
	fake.RecvStringStub = stub
}

func (fake *FakeCommunicator) RecvStringReturns(result1 string, result2 error) {
	fake.recvStringMutex.Lock()
	defer fake.recvStringMutex.Unlock()
	fake.RecvStringStub = nil
	fake.recvStringReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeCommunicator) RecvStringReturnsOnCall(i int, result1 string, result2 error) {
	fake.recvStringMutex.Lock()
	defer fake.recvStringMutex.Unlock()
	fake.RecvStringStub = nil
	if fake.recvStringReturnsOnCall == nil {
		fake.recvStringReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.recvStringReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeCommunicator) RecvStringSlice() ([]string, error) {
	fake.recvStringSliceMutex.Lock()
	ret, specificReturn := fake.recvStringSliceReturnsOnCall[len(fake.recvStringSliceArgsForCall)]
	fake.recvStringSliceArgsForCall = append(fake.recvStringSliceArgsForCall, struct {
	}{})
	stub := fake.RecvStringSliceStub
	fakeReturns := fake.recvStringSliceReturns
	fake.recordInvocation("RecvStringSlice", []interface{}{})
	fake.recvStringSliceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCommunicator) RecvStringSliceCallCount() int {
	fake.recvStringSliceMutex.RLock()
	defer fake.recvStringSliceMutex.RUnlock()
	return len(fake.recvStringSliceArgsForCall)
}

func (fake *FakeCommunicator) RecvStringSliceCalls(stub func() ([]string, error)) {
	fake.recvStringSliceMutex.Lock()
	defer fake.recvStringSliceMutex.Unlock()
	fake.RecvStringSliceStub = stub
}

func (fake *FakeCommunicator) RecvStringSliceReturns(result1 []string, result2 error) {
	fake.recvStringSliceMutex.Lock()
	defer fake.recvStringSliceMutex.Unlock()
	fake.RecvStringSliceStub = nil
	fake.recvStringSliceReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeCommunicator) RecvStringSliceReturnsOnCall(i int, result1 []string, result2 error) {
	fake.recvStringSliceMutex.Lock()
	defer fake.recvStringSliceMutex.Unlock()
	fake.RecvStringSliceStub = nil
	if fake.recvStringSliceReturnsOnCall == nil {
		fake.recvStringSliceReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.recvStringSliceReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeCommunicator) RecvVarInt() (int64, error) {
	fake.recvVarIntMutex.Lock()
	ret, specificReturn := fake.recvVarIntReturnsOnCall[len(fake.recvVarIntArgsForCall)]
	fake.recvVarIntArgsForCall = append(fake.recvVarIntArgsForCall, struct {
	}{})
	stub := fake.RecvVarIntStub
	fakeReturns := fake.recvVarIntReturns
	fake.recordInvocation("RecvVarInt", []interface{}{})
	fake.recvVarIntMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCommunicator) RecvVarIntCallCount() int {
	fake.recvVarIntMutex.RLock()
	defer fake.recvVarIntMutex.RUnlock()
	return len(fake.recvVarIntArgsForCall)
}

func (fake *FakeCommunicator) RecvVarIntCalls(stub func() (int64, error)) {
	fake.recvVarIntMutex.Lock()
	defer fake.recvVarIntMutex.Unlock()
	fake.RecvVarIntStub = stub
}

func (fake *FakeCommunicator) RecvVarIntReturns(result1 int64, result2 error) {
	fake.recvVarIntMutex.Lock()
	defer fake.recvVarIntMutex.Unlock()
	fake.RecvVarIntStub = nil
	fake.recvVarIntReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeCommunicator) RecvVarIntReturnsOnCall(i int, result1 int64, result2 error) {
	fake.recvVarIntMutex.Lock()
	defer fake.recvVarIntMutex.Unlock()
	fake.RecvVarIntStub = nil
	if fake.recvVarIntReturnsOnCall == nil {
		fake.recvVarIntReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.recvVarIntReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeCommunicator) SendFileData(arg1 io.Reader, arg2 int64) error {
	fake.sendFileDataMutex.Lock()
	ret, specificReturn := fake.sendFileDataReturnsOnCall[len(fake.sendFileDataArgsForCall)]
	fake.sendFileDataArgsForCall = append(fake.sendFileDataArgsForCall, struct {
		arg1 io.Reader
		arg2 int64
	}{arg1, arg2})
	stub := fake.SendFileDataStub
	fakeReturns := fake.sendFileDataReturns
	fake.recordInvocation("SendFileData", []interface{}{arg1, arg2})
	fake.sendFileDataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCommunicator) SendFileDataCallCount() int {
	fake.sendFileDataMutex.RLock()
	defer fake.sendFileDataMutex.RUnlock()
	return len(fake.sendFileDataArgsForCall)
}

func (fake *FakeCommunicator) SendFileDataCalls(stub func(io.Reader, int64) error) {
	fake.sendFileDataMutex.Lock()
	defer fake.sendFileDataMutex.Unlock()
	fake.SendFileDataStub = stub
}

func (fake *FakeCommunicator) SendFileDataArgsForCall(i int) (io.Reader, int64) {
	fake.sendFileDataMutex.RLock()
	defer fake.sendFileDataMutex.RUnlock()
	argsForCall := fake.sendFileDataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCommunicator) SendFileDataReturns(result1 error) {
	fake.sendFileDataMutex.Lock()
	defer fake.sendFileDataMutex.Unlock()
	fake.SendFileDataStub = nil
	fake.sendFileDataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCommunicator) SendFileDataReturnsOnCall(i int, result1 error) {
	fake.sendFileDataMutex.Lock()
	defer fake.sendFileDataMutex.Unlock()
	fake.SendFileDataStub = nil
	if fake.sendFileDataReturnsOnCall == nil {
		fake.sendFileDataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendFileDataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCommunicator) SendString(arg1 string) error {
	fake.sendStringMutex.Lock()
	ret, specificReturn := fake.sendStringReturnsOnCall[len(fake.sendStringArgsForCall)]
	fake.sendStringArgsForCall = append(fake.sendStringArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SendStringStub
	fakeReturns := fake.sendStringReturns
	fake.recordInvocation("SendString", []interface{}{arg1})
	fake.sendStringMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCommunicator) SendStringCallCount() int {
	fake.sendStringMutex.RLock()
	defer fake.sendStringMutex.RUnlock()
	return len(fake.sendStringArgsForCall)
}

func (fake *FakeCommunicator) SendStringCalls(stub func(string) error) {
	fake.sendStringMutex.Lock()
	defer fake.sendStringMutex.Unlock()
	fake.SendStringStub = stub
}

func (fake *FakeCommunicator) SendStringArgsForCall(i int) string {
	fake.sendStringMutex.RLock()
	defer fake.sendStringMutex.RUnlock()
	argsForCall := fake.sendStringArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCommunicator) SendStringReturns(result1 error) {
	fake.sendStringMutex.Lock()
	defer fake.sendStringMutex.Unlock()
	fake.SendStringStub = nil
	fake.sendStringReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCommunicator) SendStringReturnsOnCall(i int, result1 error) {
	fake.sendStringMutex.Lock()
	defer fake.sendStringMutex.Unlock()
	fake.SendStringStub = nil
	if fake.sendStringReturnsOnCall == nil {
		fake.sendStringReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendStringReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCommunicator) SendStringSlice(arg1 []string) error {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.sendStringSliceMutex.Lock()
	ret, specificReturn := fake.sendStringSliceReturnsOnCall[len(fake.sendStringSliceArgsForCall)]
	fake.sendStringSliceArgsForCall = append(fake.sendStringSliceArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.SendStringSliceStub
	fakeReturns := fake.sendStringSliceReturns
	fake.recordInvocation("SendStringSlice", []interface{}{arg1Copy})
	fake.sendStringSliceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCommunicator) SendStringSliceCallCount() int {
	fake.sendStringSliceMutex.RLock()
	defer fake.sendStringSliceMutex.RUnlock()
	return len(fake.sendStringSliceArgsForCall)
}

func (fake *FakeCommunicator) SendStringSliceCalls(stub func([]string) error) {
	fake.sendStringSliceMutex.Lock()
	defer fake.sendStringSliceMutex.Unlock()
	fake.SendStringSliceStub = stub
}

func (fake *FakeCommunicator) SendStringSliceArgsForCall(i int) []string {
	fake.sendStringSliceMutex.RLock()
	defer fake.sendStringSliceMutex.RUnlock()
	argsForCall := fake.sendStringSliceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCommunicator) SendStringSliceReturns(result1 error) {
	fake.sendStringSliceMutex.Lock()
	defer fake.sendStringSliceMutex.Unlock()
	fake.SendStringSliceStub = nil
	fake.sendStringSliceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCommunicator) SendStringSliceReturnsOnCall(i int, result1 error) {
	fake.sendStringSliceMutex.Lock()
	defer fake.sendStringSliceMutex.Unlock()
	fake.SendStringSliceStub = nil
	if fake.sendStringSliceReturnsOnCall == nil {
		fake.sendStringSliceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendStringSliceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCommunicator) SendVarInt(arg1 int64) error {
	fake.sendVarIntMutex.Lock()
	ret, specificReturn := fake.sendVarIntReturnsOnCall[len(fake.sendVarIntArgsForCall)]
	fake.sendVarIntArgsForCall = append(fake.sendVarIntArgsForCall, struct {
		arg1 int64
	}{arg1})
	stub := fake.SendVarIntStub
	fakeReturns := fake.sendVarIntReturns
	fake.recordInvocation("SendVarInt", []interface{}{arg1})
	fake.sendVarIntMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCommunicator) SendVarIntCallCount() int {
	fake.sendVarIntMutex.RLock()
	defer fake.sendVarIntMutex.RUnlock()
	return len(fake.sendVarIntArgsForCall)
}

func (fake *FakeCommunicator) SendVarIntCalls(stub func(int64) error) {
	fake.sendVarIntMutex.Lock()
	defer fake.sendVarIntMutex.Unlock()
	fake.SendVarIntStub = stub
}

func (fake *FakeCommunicator) SendVarIntArgsForCall(i int) int64 {
	fake.sendVarIntMutex.RLock()
	defer fake.sendVarIntMutex.RUnlock()
	argsForCall := fake.sendVarIntArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCommunicator) SendVarIntReturns(result1 error) {
	fake.sendVarIntMutex.Lock()
	defer fake.sendVarIntMutex.Unlock()
	fake.SendVarIntStub = nil
	fake.sendVarIntReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCommunicator) SendVarIntReturnsOnCall(i int, result1 error) {
	fake.sendVarIntMutex.Lock()
	defer fake.sendVarIntMutex.Unlock()
	fake.SendVarIntStub = nil
	if fake.sendVarIntReturnsOnCall == nil {
		fake.sendVarIntReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendVarIntReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCommunicator) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.recvFileDataMutex.RLock()
	defer fake.recvFileDataMutex.RUnlock()
	fake.recvStringMutex.RLock()
	defer fake.recvStringMutex.RUnlock()
	fake.recvStringSliceMutex.RLock()
	defer fake.recvStringSliceMutex.RUnlock()
	fake.recvVarIntMutex.RLock()
	defer fake.recvVarIntMutex.RUnlock()
	fake.sendFileDataMutex.RLock()
	defer fake.sendFileDataMutex.RUnlock()
	fake.sendStringMutex.RLock()
	defer fake.sendStringMutex.RUnlock()
	fake.sendStringSliceMutex.RLock()
	defer fake.sendStringSliceMutex.RUnlock()
	fake.sendVarIntMutex.RLock()
	defer fake.sendVarIntMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCommunicator) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ netio.Communicator = new(FakeCommunicator)
